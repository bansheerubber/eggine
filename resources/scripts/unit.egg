function Unit::onAdd(%this) {
	%this.abilities = new Array();

	%ability1 = new SnapshotAbility() {
		owner = %this;
	};
	%this.abilities.push(%ability1);

	%ability2 = new TrainedShotAbility() {
		owner = %this;
	};
	%this.abilities.push(%ability2);

	%ability3 = new OverwatchAbility() {
		owner = %this;
	};
	%this.abilities.push(%ability3);

	%this.maxMoves = 5;
	%this.maxSprintMoves = 15;
	%this.moves = 5;
	%this.sprintMoves = 15;

	%this.ap = 2;

	%this.setMaxHealth(7);
	%this.setHealth(7);
}

function Unit::coverList(%this) {
	%array = new Array();

	// if our unit is on a wall tile
	if(Tile::isWall(%this.getPosition())) {
		%map = new Map();
		%position = %this.getPosition();
		%map["position"] = %position;
		%map["vector"] = Tile::wallAlong(%position);
		%map["normal"] = Tile::wallNormal(%position);
		%map["isFull"] = true;
		%map["sameTile"] = true;
		%array.push(%map);
		return %array;
	}

	for(%i = 0; %i < 4; %i++) {
		%direction = $Tile::Directions[%i];
		%position = %direction + %this.getPosition();
		if(Tile::isTile(%position)) {
			%map = new Map();
			%map["position"] = %position;
			%map["vector"] = $Tile::Directions[(%i + 1) % 4]; // rotate vector by 90 degrees to get "along the wall" vector
			%map["isFull"] = Tile::isWall(%map["position"]);
			%map["sameTile"] = false;
			%array.push(%map);
		}
	}
	return %array;
}

// return 2 if behind impenetrable cover, return 1 if behind cover but can still be shot, return 0 if no cover at all
function Unit::testInCoverFromPosition(%this, %attacker, %attackerPosition) {
	// next section takes approx 20 us
	%direction = normalize(%this.getPosition() - %attackerPosition);
	%resultArray = raycast(%attackerPosition, %this.getPosition(), 1);
	if(%resultArray == null) {
		return $Cover::None;
	}

	// next section takes approx 70 us
	%coverList = %this.coverList();
	if(%coverList.size() == 0) { // TODO do additional tests to see if a half-height wall is obscuring us/etc
		for(%i = 0; %i < %resultArray.size(); %i++) {
			if(Tile::isWall(%resultArray[%i])) { // see if there's any walls inbetween us and the enemy
				return $Cover::Full;
			}
		}
		return $Cover::None;
	}
	// end section

	// see if there's any walls that aren't a part of the cover wall inbetween us and the enemy
	for(%i = 0; %i < %resultArray.size() - 1; %i++) {
		for(%j = 0; %j < %coverList.size(); %j++) {
			%cover = %coverList[%j];
			if(Tile::isWall(%resultArray[%i]) && !Tile::wallTest(%resultArray[%i], %cover["position"], %cover["vector"])) {
				return $Cover::Full;
			}
		}
	}

	%result = %resultArray[%resultArray.size() - 1];

	%hitCover = null; // hit cover determines the strength of the cover modifier applied to accuracy
	for(%i = 0; %i < %coverList.size(); %i++) {
		%cover = %coverList[%i];
		if(Tile::wallTest(%result, %cover["position"], %cover["vector"])) {
			%hitCover = %cover;
			break;
		}
	}

	if(%hitCover == null) {
		return $Cover::None;
	}

	// next section takes approx 70 microsections
	%candidateTiles = new Array();
	%candidateTile1 = %this.getPosition() + %hitCover["vector"];
	%candidateTile2 = %this.getPosition() - %hitCover["vector"];
	%candidateTiles.push(%this.getPosition());

	if(distance(%attackerPosition, %candidateTile1) < distance(%attackerPosition, %candidateTile2)) {
		%candidateTiles.push(%candidateTile1);
	}
	else if(distance(%attackerPosition, %candidateTile1) > distance(%attackerPosition, %candidateTile2)) {
		%candidateTiles.push(%candidateTile2);
	}

	// this is the part that takes up a disproportionate amount of time
	%hit = true;
	for(%i = 0; %i < %candidateTiles.size(); %i++) {
		if(Tile::raycastIgnoreStrays(%attackerPosition, %candidateTiles[%i], 1, %hitCover["position"], %hitCover["vector"]) == null) {
			%hit = false;
			break;
		}
	}

	if(%hit) {
		if(%hitCover["isFull"]) {
			return $Cover::Full;
		}
		else {
			return $Cover::Half;
		}
	}
	else if(%hitCover["isFull"]) {
		return $Cover::FullPartial;
	}
	else {
		return $Cover::Half;
	}
}

// return 2 if behind impenetrable cover, return 1 if behind cover but can still be shot, return 0 if no cover at all
function Unit::inCover(%this, %attacker) {
	%result = %this.testInCoverFromPosition(%attacker, %attacker.getPosition());
	if(%result != $Cover::Full) {
		return %result;
	}

	for(%i = 0; %i < 4; %i++) { // TODO handle this better
		%adjacent = Tile::getAdjacent(%attacker.getPosition(), %i);
		if(Tile::isTile(%adjacent) || raycast(%attacker.getPosition(), %adjacent) != null) {
			continue;
		}

		%result = %this.testInCoverFromPosition(%attacker, %adjacent);
		if(%result != $Cover::Full) {
			return %result;
		}
	}

	return $Cover::Full;
}

function getCoverAccuracyMod(%cover) {
	if(%cover == $Cover::None) {
		return 1;
	}
	else if(%cover == $Cover::Half) {
		return 1 / 1.5;
	}
	else if(%cover == $Cover::FullPartial) {
		return 1 / 2;
	}
	else if(%cover == $Cover::Full) {
		return 0;
	}
}

function Unit::updateUI(%this) { // if we're selected, then update the UI
	if(getChunkContainer().getSelectedCharacter() == %this) {
		%this.getDestinations().showBorder();
		%this.getSprintDestinations().showBorder($Unit::SprintBorderColor);
		%this.updateTargettingUI();
		%this.updateAbilityList();
		updatePlayerSoldiers();
	}
}

function Unit::onSelect(%this) {
	%this.updateUI();
}

function Unit::onDeSelect(%this) {
	%this.getDestinations().hideBorder();
	%this.getSprintDestinations().hideBorder();
	%this.path = %this.getPath($Unit::HoveredTile);

	if(%this.path) {
		%this.path.hideBorder();
	}
}

function Unit::addAP(%this, %ap) {
	%this.setAP(%this.ap + %ap);
}

function Unit::setAP(%this, %ap) {
	if(%ap >= 2) {
		%this.ap = 2;
		%this.moves = %this.maxMoves;
		%this.sprintMoves = %this.maxSprintMoves;
	}
	else if(%ap == 1) {
		%this.ap = 1;
		%this.moves = 0;
		%this.sprintMoves = %this.maxSprintMoves - %this.maxMoves;
	}
	else { // 0 or negative ap
		%this.sprintMoves = 0;
		%this.moves = 0;
		%this.ap = 0;
	}

	%this.updateUI();
}

function Unit::move(%this, %position) {
	%unitPosition = %this.getPosition();
	if(!isObject(%this.path)) {
		return;
	}

	%distance = (%this.path.size() - 1);

	if(%this.getDestinations().has(%position) && %this.moves >= %distance) {
		%this.addAP(-1);
		%this.setPosition(%position + {0; 0; 1});
	}
	else if(%this.getSprintDestinations().has(%position) && %this.sprintMoves >= %distance) {
		%this.addAP(-2);
		%this.setPosition(%position + {0; 0; 1});
	}
}

function Unit::updateTargettingUI(%this) {
	getHTMLElementById("enemy-icons").clear();
	%html = "";
	%team = getChunkContainer().getEnemyTeam();
	for(%i = 0; %i < %team.size(); %i++) {
		%enemy = %team.get(%i);
		// check if any of our abilities are usable against the enemy
		%usable = false;
		for(%j = 0; %j < %this.abilities.size(); %j++) {
			%ability = %this.abilities[%j];
			if(!%ability.usable(%enemy)) {
				continue;
			}
			%usable = true;
		}

		if(%usable) {
			%src = "/images/alien.png";
			if(%enemy == $Unit::SelectedTarget) {
				%src = "/images/alienSelected.png";
			}
			
			%html = %html @ "<img enemy-id=\"" @ %i @ "\" es-class=\"EnemyIconElement\" class=\"enemy-icon\" src=\"" @ %src @ "\" />";
		}
	}
	getHTMLElementById("enemy-icons").createChild(%html);
}

function Unit::updateAbilityList(%this) {
	getHTMLElementById("player-abilities").clear();
	%this.shownAbilities = 0;
	for(%i = 0; %i < %this.abilities.size(); %i++) {
		%ability = %this.abilities[%i];
		%disabled = %ability.usable($Unit::SelectedTarget) ? "" : "disabled";
		getHTMLElementById("player-abilities").createChild("<img es-class=\"AbilityElement\" ability-index=\"" @ %i @ "\" class=\"ability-icon " @ %disabled @ "\" src=\"/images/" @ %ability.icon @ "\" />");

		if(%ability.name == $Unit::SelectedAbility.name) {
			%this.selectAbility(%i); // try to select same ability on same target between units
			%selected = true;
		}

		%this.shownAbilities++;
	}

	if(!%selected) { // if we couldn't select our selected ability, then it is missing from the HTML ability list and we should hide the ability UI
		%this.selectAbility(-1);
	}
}

function updatePlayerSoldiers() {
	getHTMLElementById("player-soldiers").clear();
	%team = getChunkContainer().getPlayerTeam();
	for(%i = 0; %i < %team.size(); %i++) {
		%unit = %team.get(%i);

		%src = "/images/headshot.png";
		if(getChunkContainer().getSelectedCharacter() == %unit) {
			%src = "/images/headshotSelected.png";
		}

		%pips = "";
		for(%j = 0; %j < 2; %j++) {
			if(%j < %unit.ap) {
				%pips = %pips @ "<img class=\"pip\" src=\"/images/apPip.png\" />";
			}
			else {
				%pips = %pips @ "<img class=\"pip\" src=\"/images/apPipInactive.png\" />";
			}
		}
		
		getHTMLElementById("player-soldiers").createChild("<div es-class=\"SoldierElement\" soldier-index=\"" @ %i @ "\" class=\"soldier-icon\"><img class=\"avatar\" src=\"" @ %src @ "\" /><div class=\"info\">Max Blast<div class=\"pips\">" @ %pips @ "</div></div></div>");
	}
}

function Unit::selectAbility(%this, %index) {
	%name = getHTMLElementById("ability-description-name");
	%name.clear();
	%description = getHTMLElementById("ability-description-body");
	%description.clear();
	%button = getHTMLElementById("ability-description-button");
	%button.clear();

	if(%index == -1) {
		%this.selectedAbility = null;
		getHTMLElementById("ability-description").setStyleAttribute("display", "none");
		return;
	}
	getHTMLElementById("ability-description").setStyleAttribute("display", "block");

	if(%this.abilities[%index]) {
		%ability = %this.abilities[%index];
		%name.createChild(%ability.name);
		%description.createChild(%ability.description($Unit::SelectedTarget));

		if(%ability.usable($Unit::SelectedTarget)) {
			%button.createChild(%ability.actionName($Unit::SelectedTarget));
			%button.setStyleAttribute("display", "inline-block");
		}
		else {
			%button.setStyleAttribute("display", "none");
		}

		%this.selectedAbility = %ability;
		$Unit::SelectedAbility = %ability;
	}
	else {
		%this.selectedAbility = null;
	}
}

function Unit::selectNextAbility(%this) {
	if(%this.shownAbilities == 0) {
		return;
	}

	if(%this.selectedAbility == null) {
		%this.selectAbility(0);
		return;
	}
	
	for(%i = 0; %i < %this.abilities.size(); %i++) {
		if(%this.selectedAbility == %this.abilities[%i]) {
			%index = %i;
			break;
		}
	}

	%next = (%index + 1) % %this.abilities.size();
	%this.selectAbility(%next);
}

function Unit::selectPreviousAbility(%this) {
	if(%this.shownAbilities == 0) {
		return;
	}

	if(%this.selectedAbility == null) {
		%this.selectAbility(0);
		return;
	}
	
	for(%i = 0; %i < %this.abilities.size(); %i++) {
		if(%this.selectedAbility == %this.abilities[%i]) {
			%index = %i;
			break;
		}
	}

	%prev = (%index - 1);
	if(%prev < 0) {
		%prev = %this.abilities.size() - 1;
	}
	%this.selectAbility(%prev);
}

function Unit::triggerOverwatch(%this, %target) {
	for(%i = 0; %i < %this.abilities.size(); %i++) {
		if(%this.abilities[%i].name == "Overwatch") {
			 %this.abilities[%i].overwatch(%target);
		}
	}
}

function fireOverwatch(%target) {
	for(%i = 0; %i < getTeamCount(); %i++) {
		%team = getTeam(%i);
		if(%target.getTeam() == %team) {
			continue;
		}

		for(%j = 0; %j < %team.size(); %j++) {
			%guy = %team.get(%j);
			if(%guy.overwatch) {
				%guy.triggerOverwatch(%target);
			}
		}
	}
}

package unit {
	function Unit::setPosition(%this, %position) {
		Parent::setPosition(%this, %position);

		if(%this == getChunkContainer().getSelectedCharacter()) {
			%this.updateUI();
			%this.path = %this.getPath($Unit::HoveredTile);
			if(%this.path) {
				%this.path.showDots();
			}
		}

		fireOverwatch(%this);
	}

	function ChunkContainer::selectCharacter(%this, %character) {
		%test = getChunkContainer().getSelectedCharacter();
		if(isObject(%test)) {
			%test.onDeSelect();
		}
		
		Parent::selectCharacter(%this, %character);

		if(isObject(%character)) {
			%character.onSelect();
		}
	}
};

class SoldierElement inherits HTMLElement {
	function onClick(%this) {
		%character = getChunkContainer().getPlayerTeam().get(%this.getAttribute("soldier-index"));
		getChunkContainer().selectCharacter(%character);
		getActiveCamera().pan(getActiveCamera().getPosition(), tileToScreen(%character.getPosition()), 0.2);
		playSound("SelectUnit");
	}
};
